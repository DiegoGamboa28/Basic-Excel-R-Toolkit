/**
 * this is intended to be an interchange format for variables in different 
 * languages/contexts: currently excel (XLOPER12), COM (Variant), R (SEXP), 
 * javascript (JSON), julia (jl_value), and potentially other languages in 
 * the future. we have slightly different support requirements depending on 
 * the platforms.
 */

syntax = "proto3";
option optimize_for = SPEED;

// protip: package gets defined as a c++ namespace, so don't use anything 
// that might otherwise be defined

package BERTBuffers;

/** complex numbers */
message Complex {
  double r = 1;
  double i = 2;
}

/** array/list/matrix/frame type */
message Array {
  int32 rows = 1;
  int32 cols = 2;
  repeated Variable data = 3;
  repeated string rownames = 4;
  repeated string colnames = 5;
}

/** error types */
enum ErrorType {
  GENERIC = 0;
  NA = 1;
  INF = 2;
  PARSE = 3;
  EXECUTION = 4;
  OTHER = 15;
}

/** error has a type and/or message */
message Error {
  ErrorType type = 1;
  string message = 2;
}

/** sheet reference */
message SheetReference {
  uint32 start_row = 1;
  uint32 start_column = 2;
  uint32 end_row = 3;
  uint32 end_column = 4;
  uint64 sheet_id = 5;
}

/** basic variable type, optionally named */
message Variable {
  oneof value {
    bool nil = 1;
    bool missing = 2;
    Error err = 3;
    double num = 4;
    string str = 5;
    bool boolean = 6;
    Complex cpx = 7;
    Array arr = 8;
    SheetReference ref = 9;
    
    //uint64 external_pointer = 10;

    ExternalPointer com_pointer = 10; // taking over, maybe drop the other one

  }	
  string name = 15;
}

/** why not have a single string and then split on the RX side? */
message Code {
  repeated string line = 1;
}

/** distinction between calls and accessors (and accesor type) */
enum CallType {
  method = 0;
  get = 1;
  put = 2;
}

enum CallTarget {   
  language = 0;
  COM = 1;
  system = 2;
}

/**
 * consolidating function call, callback, COM function call, 
 * and control/system calls with arguments 
 */
message CompositeFunctionCall {

  string function = 1;
  repeated Variable arguments = 2;

  // mostly for COM

  uint64 pointer = 3;
  uint32 index = 4;
  CallType type = 5;

  // new [enum or string?]

  CallTarget target = 6;
}

/** console message */
message Console {
  oneof message {
    string text = 1;
    string err = 2;
    string prompt = 3;
  }
}


/**
 * to date, we've been constructing function descriptions by packing them
 * in normal variables. for R, we can use the "name" attribute to identify
 * them. that's not available in Julia (and wouldn't be in some other 
 * languages either). this results in inconsitent data arriving at Excel,
 * which requires language-specific handling.
 *
 * in an effort to normalize this data, and recognizing that this message
 * scheme is application-specific, we'll define specific types for function
 * descriptors (AND com calls, below).
 *
 * this type can be used for both the function itself and arguments.
 */
message FunctionElement {
  string name = 1;
  string type_name = 2;         // not used atm
  Variable default_value = 3;
  string description = 4;
  uint32 index = 5;             // added for COM
}

/** 
 * this type describes a function. adding type so we can reuse this for COM
 */
message FunctionDescriptor {
  FunctionElement function = 1;
  CallType call_type = 2;
  repeated FunctionElement arguments = 3;
}

/** 
 * list of functions. union type can't include arrays, so we need an array.
 */
message FunctionList {
  repeated FunctionDescriptor functions = 1;
}

/** for COM enums */
message EnumValue {
  string name = 1;
  int32 value = 2;
}

message EnumType {
  string name = 1;
  repeated EnumValue values = 2;
}


/** now we're getting less and less general. not sure that's a good thing. */
message ExternalPointer {

  string interface_name = 1; // d'oh (don't use the name "interface")
  uint64 pointer = 2;

  // even though the list type is useless here, it still might be worth
  // using it so we can standardize functions for walking the list. although 
  // it's probably just 1 deref, so don't kill yourself overoptimizing.

  //FunctionList functions = 3;
  repeated FunctionDescriptor functions = 3;
  repeated EnumType enums = 4;

}

/** 
 * unifying call and response, since there are some fuzzy cases,
 * callbacks, and so on. it makes sense for this to be a single 
 * message with a switch.
 *
 * FIXME: let's revert "callback" to a separate field for clarity,
 * even though it has the same type as function_call; we have space.
 *
 * FIXME: we now have two errors -- one in here (top level) and one 
 * in variable (via result). is that useful? it certainly is 
 * confusing. I suppose it distinguishes between errors in the function
 * call and results that are errors...
 */
message CallResponse {
    
  uint32 id = 1;
  bool wait = 2;      // FIXME: this can go? should we always require full transactions?

  oneof operation {

    // response types

    string err = 3;             // FIXME: use error type? [yes, work towards that]
    Variable result = 4;

    // push / notification

    Console console = 5;        // console maybe should be a separate root message, it doesn't need a response

    // call types and callbacks. what's the difference between shell 
    // command and code? context. shell command executes like it's typed
    // at the console, code is executed via parse/eval calls. 

    // OK, so why not use a flag then? 

    Code code = 6;
    string shell_command = 7;

    // function call represents generic function calls, system
    // commands, and callbacks (including COM function calls).
   
    CompositeFunctionCall function_call = 8;

    FunctionList function_list = 9; // can we just include a "repeated" element as a union member? [A: no]

  }
}

